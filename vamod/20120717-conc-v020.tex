
\RequirePackage{lineno}
\documentclass[10pt, a4paper,landscape]{article}
% -----------------------------------------------------*
\newif\ifmktable \mktablefalse
\newif\ifmkcomments \mkcommentsfalse
\newif\ifPrincipal \Principaltrue
\usepackage{multirow}
\usepackage{enumitem}
\newenvironment{mytabular}{\begin{footnotesize} \begin{center}}{\end{center} \end{footnotesize} }
\newenvironment{mytabularleft}{\begin{footnotesize} \begin{flushleft}}{\end{flushleft} \end{footnotesize} }
\newcommand{\MKcomment}[2]{\marginpar{{\underline{#1:}}\\{#2}}}
\newcommand{\MKK}[1]{\footnote{$\kappa$: #1}}
\newcommand{\MKKM}[1]{\ifmkcomments \MKcomment{Michael}{\textred{#1}} \fi}
\newcommand{\DocData}{\today}%
\newcommand{\DocTitle}{Concept VA Policy Calculation}
\newcommand{\ReportNo}{\jobname - \today}
\newcommand{\vega}[0]{\nu}
\newcommand{\myindex}[1]{#1\index{#1}}
\newcommand{\mybox}[3]{\makebox[#1\textwidth][#2]{#3}}

\newcommand{\mkeinbildxx}[2]{
      \begin{center}
      \setlength{\fboxrule}{0.0075\textwidth}\fcolorbox{mygrey}{mylightgrey}{
      \includegraphics[width=#1\textwidth]{#2}
      }
      \end{center}
       }

%\begin{center}\includegraphics[width=#1\textwidth]{#2}\end{center}}

\newcommand{\mkeinbildbigxx}[4]{\vfill
       \begin{center}%
       \setlength{\fboxrule}{#4\textwidth}\fcolorbox{mygrey}{mylightgrey}{
       \includegraphics[angle=#1,height=#2 \textheight]{#3} 
       }
       \end{center} \vfill
       }
%\begin{center}\includegraphics[width=#1\textwidth]{#2}\end{center}}

\newcommand{\mkeinbild}[1]{                    
                    \mkeinbildxx{0.95}{#1}
                    %\vspace*{2mm}
      }
\newcommand{\mkeinbildmod}[2]{\begin{center}                    
                    \mkeinbildxx{#1}{#2} 
      %\vspace*{2mm}
      \end{center}
      }

\newcommand{\mkzweibild}[2]
{                   \begin{center}
                    \begin{minipage}{.495\textwidth}%
                    \mkeinbildxx{0.95}{#1}
                    \end{minipage}\hfill%
                    \begin{minipage}{.495\textwidth}%
                    \mkeinbildxx{0.95}{#2}
                    \end{minipage}%
%\vspace*{2mm}
                  \end{center}
               }

\newcommand{\mkimg}[2]{
\includegraphics[width=0.95\textwidth]{#2}}

\newcommand{\locpic}[1]{
\includegraphics[width=0.90\textwidth]{#1}
}

%----------------------------------------------------------
\usepackage[pdftex]{graphicx}
\usepackage{a4}%
\usepackage{amssymb}%
\usepackage{courier}%                   % \ttdefault: Adobe Courier
\usepackage{color}%
\definecolor{mygrey}{rgb}{0.7,0.7,0.7}
\definecolor{mylightgrey}{rgb}{0.7,0.7,0.7}
\usepackage[pdftex]{graphicx}
\usepackage[scaled=.92]{helvet}         % \sfdefault: Adobe Helvetica
\renewcommand\familydefault{phv}
\ifmkcomments
\message{USE LARGER PAPER}
\setlength{\paperwidth}{240mm}
\else
\setlength{\paperwidth}{210mm}
\fi
\setlength{\paperheight}{297mm}%
    \textwidth=16cm% was 16cm in order to accomodate margin
    \textheight=23cm%
    \oddsidemargin=0.0cm%
    \evensidemargin=0.0cm%
\parindent=0mm

\definecolor{myred}{rgb}{1.0,0,0}
\definecolor{myblue}{rgb}{0,0,0.9}
\definecolor{mygreen}{rgb}{0.27,0.52,0.21} % 26/90/23 68/135/55
\newcommand{\textred}[1]{\textcolor{myred}{#1}}                    
\newcommand{\textblue}[1]{\textcolor{myblue}{#1}}                    
\newcommand{\textgreen}[1]{\textcolor{mygreen}{#1}}                    
\usepackage{fancyhdr}
\usepackage{lscape}
\pagestyle{fancy}
\fancyhf{} % delete current header and footer
%\fancyhead[LE,RO]{\bfseries\thepage}
%\fancyhead[LO]{{\sc \DocTitle: \DocData} }
%\fancyhead[RE]{\bfseries\leftmark}
%\fancyfoot[LE,RO]{Confidential - No onwards sharing.}
%\fancyfoot[LO]{{\sc This document is confidential and contains price sensitive information}}
%\fancyfoot[RE]{{\sc This document is confidential and contains price sensitive information}}
\fancyfoot[RE,RO]{\thepage}
\fancyhead[RE,RO]{{\large \textred{CONFIDENTIAL}}}
\fancyhead[LE,LO]{{\large \sc \textred{\DocTitle}}}
\fancyfoot[LE,LO]{{\tiny \ReportNo}}
\renewcommand{\headrulewidth}{0pt}
\addtolength{\headheight}{1.5pt}

\typeout{PDF Latex Support}
 \usepackage[pdftex,
            colorlinks=true,            % Schrift von Links in Farbe (true), sonst mit Rahmen (false)
            bookmarksnumbered=true,     % Lesezeichen im pdf mit Nummerierung
            bookmarksopen=true,         % Ã–ffnet die Lesezeichen vom pdf beim Start
            bookmarksopenlevel=0,       % Default ist maxdim
            pdfstartview=FitH,          % startet mit Seitenbreite
            linkcolor=blue,             % Standard 'red'
            citecolor=blue,             % Standard 'green'
            urlcolor=blue,              % Standard 'cyan'
            filecolor=blue,             %
            pdfauthor = {Michael\ Koller},
            pdftitle ={\DocTitle: \DocData},
            plainpages=false,pdfpagelabels]{hyperref} %
\usepackage[final]{pdfpages}
\usepackage{longtable}
\pagestyle{empty}
\begin{document}
% ================================================================
\begin{flushleft}
Michael Koller \hfill Herrliberg, \today \\
Feldstrasse 14 \\
CH 8704 Herrliberg \\
Phone: +41 44 915 41 47\\
Switzerland \\[1cm]
\end{flushleft}

\tableofcontents

\section{Aim}
The aim of {\tt vamod} is to provide a library, where for a a given protfolio of policies and a given performance vector the respective cash flows for VA products can be calculated.

The driver routine, simulating the different preformace vectors is out of scope. The respective functunality is partially provided by {\tt simlib}. This module is intended to be integrated in the {\tt MARKOVLV} family

\section{Products Modelled}
There are the following VAs:
\begin{description}
\item[GMDB:] This the VA analogon of a term insurance. Hence the loss in case of death is the difference between the agreed contractual death benefit and the respective funds value.
\item[GMAB:] This the VA analogon of a pure endowment insurance. Hence the loss in case of surviving the term of the insurance is the difference between the agreed contractual death benefit and the respective funds value.
\item[GMIB:] This is roughly speakting a GMIB where at maturity the respective guarantee is converted in an immediate payout annuity. This product will not be modelled in {\tt vamod}
\item[GMWB:] This the VA analogon of an immediate or deferred annuity. Hence the loss are the annuityies which can not be taken out of the account value
\end{description}

\section{Calculation Formulae}

{\bf General Notation}
In the following section I summarise my understanding of the economics of this sort of contract. Assume the following:
\begin{itemize}
\item Person aged $x_0$ purchases such a GMWB and pays a single premium $EE$;
\item Assume that the person starts to withdraw at age $sw$ and that the income phase starts at age $s$;
\item We use the following notation:
\subitem $F(t)$: Funds value at time $t$. To be more precise we denote with $F(t)^-$ and $F(t)^+$ the value of the funds before and after withdrawal of the annuity, respectively. In consequence we have $F(t)^+ =F(t)^- - R(t)$.
\subitem $GWB(t)$: GWB (``Guaranteed Withdrawal Balance'') value at time $t$. To be more precise we denote with $GWB(t)^-$ and $GWB(t)^+$ the value of the funds before and after withdrawal of the annuity, respectively. In consequence we have $GWB(t)^+ =GWB(t)^- - R(t)$.
\subitem $f(x)$: GAWA percentage if person starts to withdraw at age $x$;
\subitem $GAWA(t)$: maximal allowable withdrawal benefit (usually $=GWB \times f(x)$).
\subitem $R(t)$: actual amount withdrawn. Note that we have the following: $R(\xi) = 0$ for $\xi < sw$, $ 0 \le R(\xi) \le GAWA(x)$, for all $\xi \in [sw, s[$, and  $R(\xi) = GAWA(x)$, for all $\xi \ge s$, assuming that the ``for life option'' is in place and identifying $x$ and $t$ in the obvious way, eg $x(t) = t-t_0 + x_0$  
\item With $\eta(t,\tau) \in \mathbb{R}$, we denote the fund performance during the time interval $[t,\tau]$, with $\tau > t$.
\item We do not allow for changes in funds and lapses at this time and also do not consider the death of the person insured. This would add some complexity, where actually the annuities need to be weighted with the respective probabilities ${}_tp_{x}$ and in the same sense the respective death cover weighted with ${}_tp_x \, q_x$. For the moment assume that $\sum{\tau \ge 0}$ stands for ``until death''. 
\item By $X(t)$ we denote the loss at time $t$ occurring from GMWB guarantees. It is obvious that under these premises the value of the total guarantee $Y = \sum_{\tau \ge 0} (1+r(\tau))^{-\tau} X(\tau) $, where $r(\tau)$ represents the risk free interest between $[0,\tau]$.
\end{itemize}

As described above we have the following:

\begin{eqnarray*}
f(x) &=& \left\{ 
\begin{array}{cc}
5 \% & \mbox{ if } x \in [55,74], \\
6 \% & \mbox{ if } x \in [75,84], \\
7 \% & \mbox{ if } x \ge 85.
\end{array} \right.
\end{eqnarray*}

For the recursion we have at time $t_0=0$:
\begin{eqnarray*}
F(0)   & = & EE, \\
GWB(0)   & = & EE, \\
GAWA(0)& = & f(sw) \times GWB(0) .
\end{eqnarray*}

Afterwards from time $t-1 \leadsto t$ we have the following:
\begin{eqnarray*}
F(t)^- &= & (1 + \eta(t-1,t)) \times F(t-1)^+, \\
GWB(t)^- & = & \max\{ GWB(t-1)^+,\max_{k=0,1,\dots, 4} \{1 + \eta(t-1,t-1 + \frac{k}{4})  \} \times F(t-1)^+\},\\
GAWA(t) & = & \max(GAWA(t-1), f(sw) \times GWB(t)^-) ,\\ 
F(t)^+ & = & \max(0, F(t)^- - R(t)), \\
GWB(t)^+ & = & \max(0, GWB(t)^- - R(t)), \\
X(t) & = & \max(0,R(t) - F(t)^-), \\[1ex] % Note shame on me: there as an error before namely F - R instead of R -F 
\pi(Y) & = & E^{Q}\left[\sum_{\tau \ge 0} (1+r(\tau))^{-\tau} X(\tau)  \right].
\end{eqnarray*}


If we now pick a given, mortality cover -- the simplest one -- namely the payment of $GWB(t)$ in case of death, we can calculate the value of the insurance option as follows:

\begin{eqnarray*}
\pi(Y) & = & E^Q\left[\sum\limits_{\tau \ge 0}^{\infty} (1+r(\tau))^{-\tau} X(\tau) \times {}_{\tau} p_{x_0} \right],
\end{eqnarray*}

{\bf Calculation of Funds and Losses}
As opposed to the specific setting, we aim to define the change in funds value more generally, namely:
\begin{eqnarray*}
T(\omega) & = & \mbox{Future life span. T=x: means person dies aged x}\\
F(t)      & = & \mbox{As above fund value at time t}\\
CF(t)     & = & \mbox{Cash flow at time t} \\
\eta(t-1,t)&= & \mbox{Funds performance} \\
F(t)^-    &= & (1 + \eta(t-1,t)) \times F(t-1)^+, \\
F(t)^+    & = & \max(0, F(t)^- - CF(t)), \\
X(t)      & = & \max(0,R(t) - F(t)^-), \\[1ex] % Note shame on me: there as an error before namely F - R instead of R -F  
\pi(Y) & = & E^{Q\times S}\left[\sum_{\tau \ge 0} (1+r(\tau))^{-\tau} X(\tau)  \right].
\end{eqnarray*}
Note that $S$ represents the probability measure with respect to the state the PHs are in. \par

{\bf Reference Quantity for benefits}

With $R(t)$ we denote the ratcheted up funds value if ratcheting is present. With $G(t)$ we denote the guarantee value. We have the following:

\begin{eqnarray*}
R(t+1) & = & \max(R(t), S(t)) \times \delta_{RA=1} + S(t) \times  \delta_{RA=0} \\
G^{exp}(t)   & = & \left\{
\begin{array}{ccc}
1 & \mbox{if} & x< x_0 \\
(1 + \alpha) ^{x-x_0} & \mbox{if} & x_0 \le x < x_1 \\
(1 + \alpha) ^{x1-x_0} & \mbox{else}
\end{array}
\right. \\
G^{lin}(t)   & = & \left\{
\begin{array}{ccc}
1 & \mbox{if} & x< x_0 \\
(1 + \alpha\times (x-x_0)) & \mbox{if} & x_0 \le x < x_1 \\
(1 + \alpha\times (x1-x_0)) & \mbox{else}
\end{array}
\right. \\
G(t0 & = & G^{lin} \times \delta_{lin = 1} + G^{exp} \times \delta_{exp = 1} \\
BE(t) & = & \max(S(t),R(t),G(t))\\
CF(t) & = & \sum_{i=1}^n BE(t) \times I_{Event\ i \ happens}(t) \times \beta_i
\end{eqnarray*}

Note that i represents the cases ``Death'', ``Maturity'', ``Annuity payment'', ``Premium Payment''. As example for $i=$ ``Death'' we have $I_{Death}(t) =\delta_{T=t}$.





\section{Structures}
\begin{verbatim}
typdef struct VABENEFITS
{
  // Definition of Guarantee Vector
  double dStartValueGuarantee; 
  double dIncreasePA;
  int    iStartGuaranteeAge;          // x_0
  int    iEndGuaranteeAge;            // x_1
  bool   bLinear;
  bool   bExponential;
  // Take also Fund Value into Account and make max - and how (eg Ratchet)
  bool   bMaxWithFunds; //Otherwise only guarantee
  int    iRatchet;  // 0 - no otherwise every iRatchet Periods
                                     // RA
  // Which Types of Benfits
  // note if Age < Current Age --> No Benefit
  int    iEndowmentAge; //0 - no endowment - otherwise maturity age
  int    iSTerm; // 0 - no term benefit otherwise s-age
  int    iSAnnuity; // Start age Annuity
  int    iSLastAnnuity; // Age at which Annuity ceases (\infty for lifelong)
  int    iSPrem; //Last Age with Premium 
  // Levels of Benefits -- these are the beta's
  double dPctEndowment;              // F(t)
  double dPctTerm;                   // R(t)
  double dPctAnnuity;                // CF(t)
  double dPctPremium;                // X(t)
} VABENEFITS;

typedef struct VAINVESTMENT
{
  // This Structure is also for rolling forwards
  double dEE;
  double dSAA[NRFUNDS];
  int iAgeRiskFree; // Means if Age >=iAgeRiskFree All assets in risk free (asset 0) 
  // This are the current Cash Flows and 
  double dPerformance[NRFUNDS];
  double dCurrentVA;
  double dCurrentRatchet;
  double dCurrentCashFlow;
  double dCurrentLoss;
} VAINVESTMENT;

typedef struct VAPERSON
{
  long lId
  int iAge;
  int iGender;
  int iBirthYear;
  VABENEFITS * psymB;
  VAINVESTMENT * psymI; 
} VAPERSON;
\end{verbatim}

\section{Classdefinition}

\begin{verbatim}
// note that we use the following structures and objects to do
// VAPROJECT:
// 1. VAINFORCE to hold individual policydata
// 2. Simlib for simulation
// 3. GLMOD to do the exected actuarial cash flows and reserves

class VAINFORCE
{
 public:
  VAINFORCE();
  ~VAINFORCE();
  void vGotoStart();
  void nNext();
  int iAnalyseToken(char * pcString);
  VAPERSON * pGetPerson(long lId);
  VAPERSON * pNewPerson();
  VAPERSON * psymCurrentPers;

 private:
  VAPERSON * psymAllPers;

};

class VAPROJECT:VAINFORCE,SIMLIB,MARKOVLV
{
 public:
  VAPROJECT();
  ~VAPROJECT();
  double         dSetQx(long lTable, long lType, long lSex, long lTime, double dValue);  // Table 0=K, 1= R Type 0 = 2 Ordn 1= erster Ordn  
  double         dSetFx(long lTable, long lType, long lSex, long lTime, double dValue);
  double         dSetSx(long lTable, long lType, long lSex, long lTime, double dValue);
  double         dSetBaseYear(long lTable, long lType, long lSex, long lTime);
  double         dSetActualYear(long lTime);
  double         dSetDisc(long lTime, double dValue);

  void           vGenerateTrajectory();
  long           vGetState(long lTime);
  double         dGetRandCF(long lTime);
  double         dGetRandDK(long lTime, long lMoment);
  double         dGetMeanCF(long lTime, long lState, long lNrSim);
  double         dGetMeanDK(long lTime, long lState, long lNrSim);
  double	 dGetDKDetail(long lTime, long lState); // Berechnet DK's fuer jeden State.
  double         dGetCFDetail(long lTime, long lState);
  void           vNewSeed(long lSeed);
  void           vResetMeanResults();
  long           lSeed;

  void           vAddDeath(long lSex, long lX, long lS, long lNTimes, double dLeist, double dPraem, double dITechn); 
  void           vAddEndowment(long lSex, long lX, long lS, double dLeist, double dPraem, double dITechn);
  void           vAddPremium(long lSex, long lX, long lS, double dLeist, double dPraem, double dITechn);

  void           vUpdateOperator();

  double         dGetQx(long lOrder, long lTafel, long lSex, long lTime, long lYear);
  double         dSetRelativeQxForTime(long lTime, double dValue); // eg x_0 + time we multiply the qx correspondingly
  int            iReadInforce(int iP, int iL, char * strFileName);
  void           vPrintTex(char * strName);
 private:
  bool           lValid;
  bool           bTildeCalc;
  LV_VECTOR	 *psymQx[2];  // Tafel1/2 ; K oder R ; sex
  LV_VECTOR	 *psymFx[2];
  LV_VECTOR	 *psymDisc;
  LV_VECTOR      *psymSx;
  LV_VECTOR	 *psymRelQxTime;
  LV_VECTOR      *psymTilde;
  long           lBaseYear[2];
  long		 lActualYear;

  FILE   *   psymTrace;
  };


\end{verbatim}

\section{Implementation}
In order to ensure efficient processes we note the following:
\begin{itemize}
\item In a normal environment one would project the cash flows per policy and weight it with the respective actuarial
  probabilities. This means that this approach is done per policy and simulation. There is however a possibility to save a lot of
  calculations.
\item The first trick is to use the GLMOD approach where we base the  calculation on a semi-markov approach with one state per age and gender.
\item Since we are expected in present values one can in a first step
  we assume that the persons survive and die at the same time. This
  works since we have a tree structure. Moreover we can in a first step add all simulations together and divide the results only at the end by the number of simulations
\item This is more or less the approch, as the GMxB's have been explained.
\end{itemize}

Hence the implementation is as follows:

\begin{enumerate}
\item Construct an instance of {\em GLMOD} {\em Note: It is likely easier to include a GLMOD structure in the new object, because one can better implement the functionality intrinsic to the VA's. This would also have the beauty that the object is directly generalised from OMARKOV}
\item For all $i \in \{sims\}$ call  create first a capital market trajectory and do {\em DoOneSimiulation for Portfolio}
\item {\em DoOneSimiulation for Portfolio} does calculate the funds values and corresponding guarantee payment cash flows for all times $t \in T$. For each $t \in T$ one calculates rolls forwards are relevant quantities for each policy $p \in P$. The respective guarantee payments are added to the {\em GLMOD} instance via {\tt vAddEndowment(long lSex, long lX, long lS, double dLeist, double dPraem, double dITechn);}, etc. {\em Note:} These functions to add at a particular time a death or survival benefit need to be refined in {\em GLMOD}. The functunality {\tt vAddXXX} ensures that the respective benefits are added. If there are two simulations for arguments sake we just have the double, etc/
\item After having done the simulations over all $i \in \{sims\}$ the operators {\tt dGetDK(long lTime);} and {\tt dGetCF(long lTime);} are called to get the respective results for the {\em sum} of all simulations. Hence the respective results of the new object are $\frac{1}{card(\{sims\})} \times dGetDK(long\, lTime)$, etc.
\end{enumerate}

Implementation details:
\begin{itemize}
\item The implementation of the new object {\tt VAPROJECT} should form a functional perspective follow as close as possible the {\tt OMARKOV} object, eg having the following functionalities: {\tt  void           vSetInitState(long lInitState); 
  void           vGenerateTrajectory();
  long           vGetState(long lTime);
  double         dGetRandCF(long lTime);
  double         dGetRandDK(long lTime, long lMoment);
  double         dGetMeanCF(long lTime, long lState, long lNrSim);
  double         dGetMeanDK(long lTime, long lState, long lNrSim);
  void           vNewSeed(long lSeed);
  void           vResetMeanResults();
  long           lSeed;}
\item Since we might be interested in both Premiums and Benefits separately, we should consider to use the first 200 states for benefits and the following 200 for premiums. It would also be advisable to enlarge the functionality to get the respective MR for annuities and mortatality benefits separately.
\end{itemize}
% ================================================================
\end{document}
